# PRD â€” slack-zc
> Terminal Slack client with native ZeroClaw AI agent integration  
> Status: v0.2 â€” Phase 1 scope | Target: Claude Code

---

## Overview

`slack-zc` is an open source terminal Slack client built in Rust with Ratatui, designed to be containerized and distributed. It embeds a ZeroClaw AI agent (via subprocess + HTTP gateway) that operates transparently alongside the user within the same Slack workspace. The user interacts with Slack normally; ZeroClaw listens, acts on `/commands`, and responds to `@zeroclaw` mentions in threads.

Multiple Slack workspaces are supported from v0.1 â€” the user can authenticate against N workspaces and switch between them with a single keystroke.

---

## Goals

- Fast, lightweight, fully terminal-based Slack client
- ZeroClaw as a first-class citizen, not an afterthought
- Multi-workspace support from day one â€” one Slack App, N workspace sessions
- Guided onboarding TUI for both Slack OAuth and ZeroClaw setup
- Full mouse support: click, scroll, panel resize via drag
- Single Docker image distribution, no external dependencies for end user
- Open source â€” ZeroClaw stays an external dependency (subprocess, not fork)

## Non-Goals

- No GUI / Electron shell
- No fork of ZeroClaw
- No mobile or web version

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   slack-zc binary                   â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ crate:   â”‚   â”‚ crate:       â”‚   â”‚ crate:      â”‚ â”‚
â”‚  â”‚ tui      â”‚   â”‚ slack        â”‚   â”‚ agent       â”‚ â”‚
â”‚  â”‚          â”‚   â”‚              â”‚   â”‚             â”‚ â”‚
â”‚  â”‚ Ratatui  â”‚â—„â”€â”€â”‚ Slack API    â”‚   â”‚ ZeroClaw    â”‚ â”‚
â”‚  â”‚ layout   â”‚   â”‚ multi-ws     â”‚   â”‚ subprocess  â”‚ â”‚
â”‚  â”‚ mouse    â”‚   â”‚ Socket Mode  â”‚   â”‚ HTTP bridge â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚ HTTP + Bearer token
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚ zeroclaw gateway â”‚
                                    â”‚ localhost:8080   â”‚
                                    â”‚ POST /pair       â”‚
                                    â”‚ POST /webhook    â”‚
                                    â”‚ GET  /health     â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ZeroClaw requires a **pairing flow**: 6-digit one-time code at startup â†’ exchange via `POST /pair` â†’ bearer token for all subsequent calls.

---

## Repository Structure

```
slack-zc/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ crates/
â”‚   â”œâ”€â”€ tui/
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ main.rs
â”‚   â”‚       â”œâ”€â”€ app.rs             # global state, event loop, workspace switcher
â”‚   â”‚       â”œâ”€â”€ tui_handler.rs     # Tui struct: terminal + EventHandler (mouse, resize)
â”‚   â”‚       â”œâ”€â”€ ui/
â”‚   â”‚       â”‚   â”œâ”€â”€ layout.rs      # responsive 3-column layout, drag-resize state
â”‚   â”‚       â”‚   â”œâ”€â”€ sidebar.rs     # channels + DMs + workspace tabs
â”‚   â”‚       â”‚   â”œâ”€â”€ messages.rs    # messages panel + scroll state
â”‚   â”‚       â”‚   â””â”€â”€ agent_panel.rs # ZeroClaw status + logs
â”‚   â”‚       â”œâ”€â”€ onboarding/
â”‚   â”‚       â”‚   â”œâ”€â”€ mod.rs         # onboarding state machine
â”‚   â”‚       â”‚   â”œâ”€â”€ slack_setup.rs # step: Slack app credentials entry
â”‚   â”‚       â”‚   â”œâ”€â”€ oauth_flow.rs  # step: OAuth browser flow + callback
â”‚   â”‚       â”‚   â””â”€â”€ zc_setup.rs    # step: ZeroClaw API key + provider
â”‚   â”‚       â”œâ”€â”€ input.rs           # mode detection (/, @, normal)
â”‚   â”‚       â””â”€â”€ keybinds.rs        # keyboard + mouse bindings + hit registry
â”‚   â”œâ”€â”€ slack/
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ auth.rs            # OAuth + xoxp- token storage (per workspace)
â”‚   â”‚       â”œâ”€â”€ api.rs             # Web API calls
â”‚   â”‚       â”œâ”€â”€ socket.rs          # Socket Mode real-time events
â”‚   â”‚       â””â”€â”€ types.rs           # Channel, Message, User, Workspace structs
â”‚   â””â”€â”€ agent/
â”‚       â””â”€â”€ src/
â”‚           â”œâ”€â”€ runner.rs          # install check + spawn gateway + pairing
â”‚           â”œâ”€â”€ gateway.rs         # HTTP: /pair, /health, /webhook
â”‚           â””â”€â”€ commands.rs        # /rÃ©sume, /draft, /cherche stubs
â”œâ”€â”€ config/
â”‚   â””â”€â”€ default.toml
â”œâ”€â”€ Dockerfile
â””â”€â”€ docker-compose.yml
```

---

## Phase 1 â€” TUI Fonctionnel + Bridge Bootstrap

### 1.1 â€” Project Scaffold

```toml
# config/default.toml
[slack]
client_id     = ""
client_secret = ""
redirect_port = 3000

[zeroclaw]
binary_path  = "zeroclaw"
gateway_port = 8080
auto_start   = true

[llm]
provider = "openrouter"
api_key  = ""
```

Session stored at `~/.slack-zc/session.json` (aes-gcm encrypted):

```json
{
  "workspaces": [
    {
      "team_id": "T123",
      "team_name": "Acme",
      "xoxp_token": "<encrypted>",
      "xapp_token": "<encrypted>",
      "active": true
    }
  ],
  "zeroclaw_bearer": "<encrypted>"
}
```

---

### 1.2 â€” Onboarding TUI

On first launch (no session.json), show a full-screen guided wizard rendered in Ratatui:

| Step | Content |
|------|---------|
| 1 | Welcome screen â€” explain what will be configured â†’ `[Enter]` to continue |
| 2 | Slack App credentials â€” two text fields: Client ID + Client Secret |
| 3 | OAuth browser flow â€” open browser, spinner while waiting for callback, confirm workspace |
| 4 | ZeroClaw check â€” if binary not found offer install; if no config run `zeroclaw onboard` |
| 5 | ZeroClaw pairing â€” spawn gateway, capture 6-digit code, call `POST /pair`, store bearer |
| 6 | Done â€” summary screen, `[Enter]` to launch main TUI |

If ZeroClaw was already configured before, steps 4â€“5 are short-circuited.

---

### 1.3 â€” Slack OAuth (`crate:slack`)

- Load session on startup, validate via `auth.test`
- If invalid: show modal OAuth re-auth overlay
- Multi-workspace: store N workspace entries, one `active: true` at a time

Required scopes:
```
channels:read  channels:history  channels:write
groups:read    groups:history    groups:write
im:read        im:history        im:write
mpim:read      mpim:history      mpim:write
chat:write     users:read        reactions:read
```

---

### 1.4 â€” Multi-Workspace Support

Workspace tab bar in sidebar header:

```
â”Œâ”€ WORKSPACES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [Acme] [DataSci] [+add]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Switching:** `Ctrl+W` cycle, click tab, `Ctrl+Shift+W` picker overlay  
**Adding:** `Ctrl+N` or `[+add]` â†’ abbreviated onboarding (OAuth only, reuses ZeroClaw config)  
**Architecture:** one `tokio::spawn` Socket Mode task per workspace, all kept alive simultaneously

```rust
pub struct AppState {
    pub workspaces: Vec<WorkspaceState>,
    pub active_workspace: usize,
}

pub struct WorkspaceState {
    pub team_id: String,
    pub team_name: String,
    pub token: String,
    pub channels: Vec<Channel>,
    pub active_channel: Option<String>,
    pub messages: HashMap<String, VecDeque<Message>>,
    pub socket_task: Option<JoinHandle<()>>,
    pub unread: HashMap<String, u32>,
}
```

---

### 1.5 â€” Slack API (`crate:slack`)

```rust
// types.rs
pub struct Channel { pub id: String, pub name: String, pub is_dm: bool, pub unread_count: u32 }
pub struct Message { pub ts: String, pub user_id: String, pub username: String, pub text: String }
pub struct User    { pub id: String, pub name: String, pub display_name: String }

// api.rs
pub async fn list_channels(token: &str) -> Result<Vec<Channel>>
pub async fn list_dms(token: &str) -> Result<Vec<Channel>>
pub async fn get_history(token: &str, channel_id: &str, limit: u32) -> Result<Vec<Message>>
pub async fn send_message(token: &str, channel_id: &str, text: &str) -> Result<()>
pub async fn get_user(token: &str, user_id: &str) -> Result<User>
```

---

### 1.6 â€” Socket Mode (`crate:slack`)

- One `tokio::spawn` task per workspace
- URL obtained dynamically via `apps.connections.open` (never hardcoded)
- Events pushed to shared `mpsc` channel consumed by `app.rs`
- Reconnection with exponential backoff (max 30s)
- `xapp-` token stored per workspace (`connections:write` scope required)

---

### 1.7 â€” TUI Layout

```
â”Œâ”€ slack-zc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â— Acme  [Acme] [DataSci] [+]   âš¡ zeroclaw: â— active          [?] help     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”¤
â”‚ CHANNELS     â”‚ # mlops-general                  â”‚ âš¡ ZEROCLAW               â”‚
â”‚              â”‚                                  â”‚                           â”‚
â”‚ # general  3 â”‚ 10:21 seb    message text        â”‚ â–¶ paired + active         â”‚
â”‚ # mlops    â–¶ â”‚ 10:22 alice  response            â”‚                           â”‚
â”‚ # random     â”‚ 10:23âš¡[zc]  rÃ©sumÃ© gÃ©nÃ©rÃ©       â”‚ â”„ last action â”„â”„â”„â”„â”„â”„â”„â”„  â”‚
â”‚              â”‚ 10:25 bob    merci !             â”‚ /rÃ©sume #mlops            â”‚
â”‚ DMs          â”‚ 10:26 seb    @zeroclaw brief     â”‚ â†’ 47 msgs read            â”‚
â”‚  @ alice     â”‚ 10:26âš¡[zc]  â— typing...         â”‚ â†’ summary OK âœ“            â”‚
â”‚              â”‚                                  â”‚                           â”‚
â”‚              â”‚                                  â”‚ â”„ memory â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„  â”‚
â”‚              â”‚                                  â”‚ "projet safran"           â”‚
â”‚              â”‚                                  â”‚ "demo vendredi"           â”‚
â”‚              â”‚                                  â”‚                           â”‚
â”‚              â”‚                                  â”‚ â”„ commands â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„  â”‚
â”‚              â”‚                                  â”‚ /rÃ©sume [#channel]        â”‚
â”‚              â”‚                                  â”‚ /draft [intent]           â”‚
â”‚              â”‚                                  â”‚ /cherche [text]           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [ğŸ’¬] > _                                                                     â”‚
â”‚ Enter: send  /: cmd  @zeroclaw: mention  Ctrl+K: search  Ctrl+Q: quit       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Layout constraints:**

| Panel | Constraint | Default | Draggable range |
|-------|-----------|---------|-----------------|
| Sidebar | `Constraint::Length(w)` | 20 | 15â€“35 |
| Agent panel | `Constraint::Length(w)` | 26 | 20â€“40 |
| Messages | `Constraint::Min(40)` | fills remainder | â€” |
| Input bar | `Constraint::Length(3)` | fixed | â€” |
| Topbar | `Constraint::Length(1)` | fixed | â€” |

Terminal resize â†’ handled automatically by Ratatui on every render against `frame.area()`.  
Panel resize â†’ `drag_state: Option<DragTarget>` in AppState, updated on `MouseEventKind::Drag`.

---

### 1.8 â€” Mouse + EventHandler (`tui_handler.rs`)

Based on the official Ratatui recipe (ratatui.rs/recipes/apps/terminal-and-event-handler):

```rust
pub struct Tui {
    pub terminal: ratatui::Terminal<Backend<std::io::Stderr>>,
    pub task: JoinHandle<()>,
    pub cancellation_token: CancellationToken,
    pub event_rx: UnboundedReceiver<Event>,
    pub event_tx: UnboundedSender<Event>,
    pub frame_rate: f64,  // 30.0
    pub tick_rate: f64,   // 4.0
    pub mouse: bool,      // always true
}

pub enum Event {
    Init, Quit, Tick, Render,
    Key(KeyEvent),
    Mouse(MouseEvent),
    Resize(u16, u16),
    FocusGained, FocusLost,
    Paste(String),
}
```

**Hit registry** (Ratatui has no built-in click routing):

```rust
pub struct HitRegistry {
    regions: Vec<(Rect, HitTarget)>,
}

pub enum HitTarget {
    Channel(String),
    WorkspaceTab(usize),
    AddWorkspace,
    SidebarDivider,
    AgentDivider,
    Message(String),
}

impl HitRegistry {
    pub fn clear(&mut self) { self.regions.clear(); }
    pub fn register(&mut self, rect: Rect, target: HitTarget) {
        self.regions.push((rect, target));
    }
    pub fn hit(&self, col: u16, row: u16) -> Option<&HitTarget> {
        self.regions.iter().rev().find(|(r, _)|
            col >= r.x && col < r.x + r.width &&
            row >= r.y && row < r.y + r.height
        ).map(|(_, t)| t)
    }
}
```

Clear + rebuild registry on every render. Pass `&mut hit_registry` into render functions.

---

### 1.9 â€” Input Modes

```rust
pub enum InputMode {
    Normal,        // free text â†’ send to Slack on Enter
    AgentCommand,  // starts with "/" â†’ intercepted, NOT sent to Slack
    AgentMention,  // starts with "@zeroclaw" â†’ Slack + agent
}
```

Mode indicator: `[ğŸ’¬]` `[âš¡]` `[ğŸ¤–]`

---

### 1.10 â€” Keybindings

| Key | Action |
|-----|--------|
| `â†‘ / â†“` | Scroll messages |
| `Mouse scroll` | Scroll messages (in messages panel) |
| `Alt+â†‘/â†“` | Previous / next channel |
| `Ctrl+W` | Switch to next workspace |
| `Ctrl+N` | Add new workspace |
| `Click workspace tab` | Switch workspace |
| `Ctrl+K` | Channel search overlay |
| `Ctrl+F` | Search in current channel |
| `Ctrl+Q` | Quit |
| `Ctrl+T` | Cycle theme (dark / light / hacker) |
| `?` | Toggle keybinds help overlay |
| `Click channel` | Select channel |
| `Click divider + drag` | Resize sidebar or agent panel |
| `Tab` | (Phase 2) AI draft suggestion â€” stub |

---

### 1.11 â€” ZeroClaw Bridge Bootstrap (`crate:agent`)

**runner.rs â€” full startup sequence:**

```
1. Check zeroclaw binary in PATH
   â†’ Not found: warn in agent panel, skip agent

2. Check ~/.zeroclaw/config.toml
   â†’ Not found: warn (should have been handled by onboarding)

3. Spawn `zeroclaw gateway --port 8080`
   â†’ Pipe stdout, read line by line

4. Read pairing code from stdout (timeout: 5s)
   regex: r"(?i)pairing\s+code[:\s]+(\d{6})"

5. POST /pair
   Header: X-Pairing-Code: <code>
   Response: { "token": "<bearer>" }
   Store bearer in session.json

6. GET /health
   Header: Authorization: Bearer <token>
   â†’ 200: panel shows "â— active"
   â†’ Error: panel shows "âš  pairing failed"

7. On exit: SIGTERM to subprocess
```

**gateway.rs:**

```rust
pub struct GatewayClient {
    http: reqwest::Client,
    base_url: String,
    bearer: Option<String>,
}

impl GatewayClient {
    pub async fn pair(&mut self, code: &str) -> Result<()>
    pub async fn health_check(&self) -> Result<bool>
    pub async fn send_to_agent(&self, message: &str) -> Result<String>  // stub Phase 1
}
```

**Panel states:**

```
â–¶ starting...    â†’ subprocess spawned
âš™ pairing...     â†’ calling POST /pair
â— active         â†’ paired + health OK
âš  unavailable   â†’ binary missing or timeout
âœ— error: <msg>  â†’ subprocess crashed
```

---

## âš  Implementation Tips for Claude Code

### 1. Crossterm version conflict

Never add `crossterm` as a direct dependency at a different version than what ratatui bundles. Use the re-export:

```rust
// CORRECT
use ratatui::crossterm::event::{EnableMouseCapture, DisableMouseCapture};

// WRONG â€” creates two separate event queues, raw mode never restored
use crossterm::event::EnableMouseCapture;  // if version differs
```

Verify with `cargo tree -p crossterm` that only one version exists in the graph.

### 2. Terminal cleanup on panic

Implement `Drop` on `Tui` to guarantee terminal restoration even on panic:

```rust
impl Drop for Tui {
    fn drop(&mut self) {
        let _ = self.exit(); // never panic in Drop
    }
}
```

Also install a panic hook (use `color_eyre`) that calls `ratatui::restore()` before printing the panic message.

### 3. Mouse hit testing â€” Rect has no `.contains()` in stable

Implement manually:

```rust
fn rect_contains(rect: &Rect, col: u16, row: u16) -> bool {
    col >= rect.x && col < rect.x + rect.width &&
    row >= rect.y && row < rect.y + rect.height
}
```

Never store `Rect` values across frames â€” recompute on every render.

### 4. ZeroClaw pairing code is on stdout, not stderr

Read stdout line by line with timeout. Keep draining after pairing or the buffer fills and blocks the subprocess:

```rust
let stdout = child.stdout.take().expect("stdout must be piped");
let mut reader = BufReader::new(stdout).lines();
let re = Regex::new(r"(?i)pairing\s+code[:\s]+(\d{6})").unwrap();

let code = timeout(Duration::from_secs(5), async {
    while let Some(line) = reader.next_line().await? {
        if let Some(caps) = re.captures(&line) {
            return Ok::<_, anyhow::Error>(caps[1].to_string());
        }
    }
    Err(anyhow!("pairing code not found"))
}).await??;

// Spawn a separate task to keep draining stdout after pairing
tokio::spawn(async move { while reader.next_line().await.ok().flatten().is_some() {} });
```

### 5. oauth.v2.access â€” use the user token, not the bot token

The top-level `access_token` is the bot token (`xoxb-`). We need `authed_user.access_token` (`xoxp-`):

```rust
#[derive(Deserialize)]
struct OAuthResponse {
    ok: bool,
    access_token: String,     // xoxb- bot token â† NOT this one
    authed_user: AuthedUser,
    team: Team,
}

#[derive(Deserialize)]
struct AuthedUser {
    id: String,
    access_token: String,     // xoxp- â† use this
}
```

### 6. Socket Mode WSS URL is dynamic

Never hardcode the WebSocket URL. Obtain it by calling `apps.connections.open` first:

```rust
// POST https://slack.com/api/apps.connections.open
// Header: Authorization: Bearer <xapp-token>
// Response contains: { "url": "wss://wss-primary.slack.com/link/..." }
```

### 7. aes-gcm â€” random nonce per encryption, prepend to ciphertext

```rust
fn encrypt(key: &[u8; 32], plaintext: &[u8]) -> Vec<u8> {
    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(key));
    let mut nonce_bytes = [0u8; 12];
    OsRng.fill_bytes(&mut nonce_bytes);
    let nonce = Nonce::from_slice(&nonce_bytes);
    let ct = cipher.encrypt(nonce, plaintext).expect("encryption failed");
    [nonce_bytes.as_slice(), &ct].concat()  // nonce prepended
}
```

Encryption key stored at `~/.slack-zc/.secret_key` with `chmod 600`, generated on first run.

---

## Key Dependencies

```toml
# workspace
tokio         = { version = "1", features = ["full"] }
serde         = { version = "1", features = ["derive"] }
serde_json    = "1"
reqwest       = { version = "0.12", features = ["json"] }
anyhow        = "1"
regex         = "1"

# crates/tui
ratatui       = "0.29"
# DO NOT add crossterm directly â€” use ratatui::crossterm re-export
futures       = "0.3"
tokio-util    = "0.7"
color-eyre    = "0.6"

# crates/slack
tokio-tungstenite = "0.26"
oauth2            = "4"
aes-gcm           = "0.10"
```

---

## Phase 2 â€” ZeroClaw Commands (future)

- Wire `/rÃ©sume`, `/draft`, `/cherche` â†’ `POST /webhook`
- Agent responses in panel + Slack thread
- `Tab` completion with agent context

## Phase 3 â€” Polish (future)

- Thread view, emoji reactions, right-click context menu, file upload

## Phase 4 â€” Docker (future)

```dockerfile
FROM rust:1.82-alpine AS builder
WORKDIR /app
COPY . .
RUN cargo build --release --locked

FROM alpine:3.20
RUN curl -LsSf https://raw.githubusercontent.com/zeroclaw-labs/zeroclaw/main/scripts/install.sh | sh
COPY --from=builder /app/target/release/slack-zc /usr/local/bin/slack-zc
ENTRYPOINT ["slack-zc"]
```

---

## Acceptance Criteria â€” Phase 1

- [ ] `cargo build --release` succeeds with no warnings
- [ ] Cold start â†’ onboarding TUI walks through all 6 steps
- [ ] After onboarding: ZeroClaw paired, bearer stored in session.json
- [ ] Subsequent launches: direct to main TUI, no onboarding
- [ ] Channel list loads on startup
- [ ] Messages load on channel select
- [ ] User can send a message, it appears in Slack
- [ ] Incoming messages appear in real-time (Socket Mode)
- [ ] Mouse click on channel â†’ selects it
- [ ] Mouse scroll in messages panel â†’ scrolls
- [ ] Terminal resize â†’ layout adapts without crash
- [ ] Drag sidebar divider â†’ width changes
- [ ] `Ctrl+W` switches workspace
- [ ] `Ctrl+N` adds second workspace (OAuth only)
- [ ] Workspace tab shows unread count badge
- [ ] `Alt+â†‘/â†“` navigates channels
- [ ] `Ctrl+K` opens channel search overlay
- [ ] Input mode indicator updates for `/`, `@zeroclaw`, plain text
- [ ] zeroclaw present â†’ daemon starts, pairing completes, panel `â— active`
- [ ] zeroclaw absent â†’ panel `âš  unavailable`, TUI works normally
- [ ] `Ctrl+Q` exits cleanly, terminal fully restored
- [ ] Panic during runtime â†’ terminal restored before panic message
